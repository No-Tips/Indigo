using System.Linq;
using Content.Shared.InterfaceGuidelines;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using static Robust.Shared.Maths.Direction;


namespace Content.Client.UserInterface.Controls;


/// <summary>
///     A simple yet good-looking tab container using normal UI elements with multiple styles
///     <br />
///     Because nobody else could do it better.
/// </summary>
[GenerateTypedNameReferences]
public sealed partial class FancyTabContainer : BoxContainer
{
    private readonly Dictionary<Control, FancyButton> _tabs     = new();
    private readonly List<Control>                    _controls = new();
    private readonly ButtonGroup                      _tabGroup = new(false);

    /// All children within the <see cref="ContentContainer"/>
    public OrderedChildCollection Contents => ContentContainer.Children;

    /// All children within the <see cref="ContentContainer"/> that are visible
    public List<Control> VisibleContents => Contents.Where(c => c == CurrentControl).ToList();

    /// All children within the <see cref="TabContainer"/>
    public OrderedChildCollection Tabs => TabContainer.Children;

    /// All children within the <see cref="TabContainer"/> that are visible
    public List<Control> VisibleTabs => Tabs.Where(c => c.Visible).ToList();

    public Control? CurrentControl { get; private set; }

    public int? CurrentTab =>
        _controls.FirstOrDefault(control => control == CurrentControl) switch
        {
            { } control => _controls.IndexOf(control),
            _           => null
        };


    /// <inheritdoc cref="FancyTabContainer"/>
    public FancyTabContainer()
    {
        RobustXamlLoader.Load(this);

        LayoutChanged(TabLocation);
        ScrollingChanged(HScrollEnabled, VScrollEnabled);
    }

    protected override void ChildRemoved(Control child)
    {
        if (_tabs.Remove(child, out var button))
            button.Dispose();

        // Set the current tab to a different control
        if (CurrentControl == child)
        {
            var previous = _controls.IndexOf(child) - 1;

            if (previous > -1)
                SelectTab(_controls[previous]);
            else
                CurrentControl = null;
        }

        _controls.Remove(child);
        base.ChildRemoved(child);
        UpdateTabMerging();
    }

    // A fun display of every location for the tabs if you want it
    // private TimeSpan _lastLayoutChange = TimeSpan.Zero;
    // private TimeSpan _nextLayoutChange = TimeSpan.Zero;
    // protected override void FrameUpdate(FrameEventArgs args)
    // {
    //     base.FrameUpdate(args);
    //
    //     _lastLayoutChange += TimeSpan.FromSeconds(args.DeltaSeconds);
    //     // Change the layout every second such that the tabs go in a circle
    //     if (_lastLayoutChange.TotalSeconds < _nextLayoutChange.TotalSeconds)
    //         return;
    //
    //     _lastLayoutChange = _nextLayoutChange;
    //     _nextLayoutChange = _lastLayoutChange + TimeSpan.FromSeconds(2);
    //
    //     LayoutChanged(TabLocation switch
    //     {
    //         North => East,
    //         East => South,
    //         South => West,
    //         West => North,
    //         _ => North,
    //     });
    // }


    /// <summary>
    ///     Adds a tab to this container
    /// </summary>
    /// <param name="control">The tab contents</param>
    /// <param name="title">The title of the tab</param>
    /// <param name="updateTabMerging">Whether the tabs should fix their styling automatically. Useful if you're doing tons of updates at once</param>
    /// <returns>The index of the new tab</returns>
    public int AddTab(
        Control control,
        string? title,
        string? icon             = null,
        bool    iconFilled       = false,
        bool    updateTabMerging = true
    )
    {
        control.Orphan();

        var button = new FancyButton
        {
            Group            = _tabGroup,
            MinHeight        = 32,
            MaxHeight        = 32,
            HorizontalExpand = true,
            Icon             = icon,
            Filled           = iconFilled
        };
        button.OnPressed += _ => SelectTab(control);

        if (!string.IsNullOrEmpty(title))
            button.Text = title;

        TabContainer.AddChild(button);
        ContentContainer.AddChild(control);
        _controls.Add(control);
        _tabs.Add(control, button);

        // Show it if it has content
        if (ContentContainer.ChildCount > 1)
            control.Visible = false;
        else
            // Select it if it's the only tab
            SelectTab(control);

        if (updateTabMerging)
            UpdateTabMerging();

        return ChildCount - 1;
    }

    /// <summary>
    ///     Removes/Disposes the tab associated with the given index
    /// </summary>
    /// <param name="index">The index of the tab to remove</param>
    /// <param name="updateTabMerging">Whether the tabs should fix their styling automatically. Useful if you're doing tons of updates at once</param>
    /// <returns>True if the tab was removed, false otherwise</returns>
    public bool RemoveTab(int index, bool updateTabMerging = true)
    {
        if (index < 0 || index >= _controls.Count)
            return false;

        var control = _controls[index];
        RemoveTab(control, updateTabMerging);

        return true;
    }

    /// <summary>
    ///     Removes/Disposes the tab associated with the given control
    /// </summary>
    /// <param name="control">The control to remove</param>
    /// <param name="updateTabMerging">Whether the tabs should fix their styling automatically. Useful if you're doing tons of updates at once</param>
    /// <returns>True if the tab was removed, false otherwise</returns>
    public bool RemoveTab(Control control, bool updateTabMerging = true)
    {
        if (!_tabs.TryGetValue(control, out var button))
            return false;

        button.Dispose();
        control.Dispose();

        if (updateTabMerging)
            UpdateTabMerging();

        return true;
    }


    /// Sets the title of the tab associated with the given index
    public void SetTabTitle(int index, string title)
    {
        if (index < 0 || index >= _controls.Count)
            return;

        var control = _controls[index];
        SetTabTitle(control, title);
    }

    /// Sets the title of the tab associated with the given control
    public void SetTabTitle(Control control, string title)
    {
        if (!_tabs.TryGetValue(control, out var button))
            return;

        button.Text = title;
    }

    /// Shows or hides the tab associated with the given index
    public void SetTabVisible(int index, bool visible)
    {
        if (index < 0 || index >= _controls.Count)
            return;

        var control = _controls[index];
        SetTabVisible(control, visible);
    }

    /// Shows or hides the tab associated with the given control
    public void SetTabVisible(Control control, bool visible)
    {
        if (!_tabs.TryGetValue(control, out var button))
            return;

        button.Visible = visible;
        UpdateTabMerging();
    }

    /// Selects the tab associated with the control
    public void SelectTab(Control control)
    {
        if (CurrentControl != null)
            CurrentControl.Visible = false;

        var button = _tabs[control];
        button.Pressed  = true;
        control.Visible = true;
        CurrentControl  = control;
    }

    /// Sets the style of every visible tab's Button to be Open to Right, Both, or Left depending on position
    public void UpdateTabMerging()
    {
        var visibleTabs = VisibleTabs;

        switch (visibleTabs.Count)
        {
            case 0:
                return;
            case 1:
            {
                var button = (FancyButton) visibleTabs[0];

                button.Style = ButtonStyle.Default;

                if (FirstTabOpenBoth)
                    button.Style = ButtonStyle.OpenBoth;

                return;
            }
        }

        for (var i = 0; i < visibleTabs.Count; i++)
        {
            var button = (FancyButton) visibleTabs[i];

            button.Style = ButtonStyle.Default;

            if (FirstTabOpenBoth && i == 0 || LastTabOpenBoth && i == visibleTabs.Count - 1)
            {
                button.Style = ButtonStyle.OpenBoth;

                continue;
            }

            var position = i switch
            {
                0                                 => 0,
                _ when i == visibleTabs.Count - 1 => 2,
                _                                 => 1
            };

            button.Style = GetDirection(TabLocation, position);
        }

        return;

        ButtonStyle GetDirection(Direction direction, int position) =>
            position switch
            {
                // First
                0 => direction switch
                {
                    North => ButtonStyle.OpenRight,
                    South => ButtonStyle.OpenRight,
                    East  => ButtonStyle.OpenLeft,
                    West  => ButtonStyle.OpenLeft,
                    _     => ButtonStyle.OpenRight
                },
                // Middle
                1 => ButtonStyle.OpenBoth,
                // Last
                2 => direction switch
                {
                    North => ButtonStyle.OpenLeft,
                    South => ButtonStyle.OpenLeft,
                    East  => ButtonStyle.OpenRight,
                    West  => ButtonStyle.OpenRight,
                    _     => ButtonStyle.OpenLeft
                },
                _ => ButtonStyle.OpenBoth
            };
    }
}
