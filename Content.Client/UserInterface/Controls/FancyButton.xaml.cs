// Copyright (C) 2025 Igor Spichkin

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.

// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

using Content.Client.InterfaceGuidelines;
using Content.Shared.InterfaceGuidelines;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Timing;


namespace Content.Client.UserInterface.Controls;


[GenerateTypedNameReferences, Virtual,]
public partial class FancyButton : ContainerButton
{
    private readonly bool _isInited;
    private          bool _isDirty;

    public ButtonStyle Style
    {
        get => _style;
        set
        {
            _style   = value;
            _isDirty = true;
        }
    }

    public ButtonColor Color
    {
        get => _color;
        set
        {
            _color   = value;
            _isDirty = true;
        }
    }

    public string? Text { get => ButtonLabel.Text; set => ButtonLabel.Text = value; }

    public string? Icon
    {
        get => _icon;
        set
        {
            _icon    = value;
            _isDirty = true;
        }
    }

    public bool IsIconAtLeft
    {
        get => _isIconAtLeft;
        set
        {
            _isIconAtLeft = value;
            _isDirty      = true;
        }
    }

    public FontType? FontType
    {
        get => _fontType;
        set
        {
            _fontType = value;
            _isDirty  = true;
        }
    }

    public TextStyle? TextStyle
    {
        get => _textStyle;
        set
        {
            _textStyle = value;
            _isDirty   = true;
        }
    }

    public TextStyle? IconTextStyle
    {
        get => _iconTextStyle;
        set
        {
            _iconTextStyle = value;
            _isDirty       = true;
        }
    }

    public FontWeight? FontWeight
    {
        get => _fontWeight;
        set
        {
            _fontWeight = value;
            _isDirty    = true;
        }
    }

    public FontWeight? IconFontWeight
    {
        get => _iconFontWeight;
        set
        {
            _iconFontWeight = value;
            _isDirty        = true;
        }
    }

    public bool? Filled
    {
        get => _filled;
        set
        {
            _filled  = value;
            _isDirty = true;
        }
    }

    public Color? FontColor
    {
        get => _fontColor;
        set
        {
            _fontColor = value;
            _isDirty   = true;
        }
    }

    private ButtonStyle _style = ButtonStyle.Default;
    private ButtonColor _color = ButtonColor.Default;
    private string?     _icon;
    private TextStyle?  _textStyle;
    private FontWeight? _fontWeight;
    private FontType?   _fontType;
    private bool?       _filled;
    private FontWeight? _iconFontWeight;
    private TextStyle?  _iconTextStyle;
    private bool        _isIconAtLeft = true;
    private Color?      _fontColor;

    public FancyButton()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        _isDirty  = true;
        _isInited = true;
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);

        if (!_isDirty)
            return;

        _isDirty = false;
        UpdateAppearance();
    }

    protected override void DrawModeChanged()
    {
        base.DrawModeChanged();

        if (!_isInited)
            return;

        UpdateAppearance();
    }

    private void UpdateAppearance()
    {
        var fontColor = DrawMode == DrawModeEnum.Disabled
            ? Colors.ButtonDisabledLabel
            : FontColor ?? Colors.ButtonLabel;

        ButtonLeftIconLabel.FontColorOverride  = fontColor;
        ButtonRightIconLabel.FontColorOverride = fontColor;
        ButtonLabel.FontColorOverride          = fontColor;

        FancyIcon iconLabel;
        FancyIcon inactiveIconLabel;

        if (IsIconAtLeft)
        {
            iconLabel                             = ButtonLeftIconLabel;
            inactiveIconLabel                     = ButtonRightIconLabel;
            ButtonRightIconLabel.Text             = " ";
            ButtonRightIconLabel.HorizontalExpand = false;
            ButtonRightIconLabel.Visible          = true;
        }
        else
        {
            iconLabel                            = ButtonRightIconLabel;
            inactiveIconLabel                    = ButtonLeftIconLabel;
            ButtonLeftIconLabel.Text             = " ";
            ButtonLeftIconLabel.HorizontalExpand = false;
            ButtonLeftIconLabel.Visible          = true;
        }

        var isIconOnly = string.IsNullOrEmpty(Text);

        if (Icon is { } icon)
        {
            iconLabel.Filled     = Filled ?? true;
            iconLabel.TextStyle  = IconTextStyle ?? InterfaceGuidelines.TextStyle.Title2;
            iconLabel.FontWeight = IconFontWeight ?? FontWeight ?? InterfaceGuidelines.FontWeight.Medium;
            iconLabel.Text       = icon;
        }

        if (isIconOnly)
        {
            iconLabel.Visible         = true;
            inactiveIconLabel.Visible = false;
        }

        iconLabel.HorizontalExpand         = isIconOnly;
        ButtonLabel.HorizontalExpand       = !isIconOnly;
        ButtonContainer.SeparationOverride = isIconOnly ? 0 : 8;

        ButtonLabel.FontType   = FontType ?? InterfaceGuidelines.FontType.SansSerif;
        ButtonLabel.FontWeight = FontWeight ?? InterfaceGuidelines.FontWeight.Medium;
        ButtonLabel.TextStyle  = TextStyle ?? InterfaceGuidelines.TextStyle.Body;

        if (Style == ButtonStyle.Ghost)
        {
            ButtonContainer.Margin = new(4.0f, 2.0f);

            StyleBoxOverride = new RectBox
            {
                Rounding        = new(0.0f),
                BackgroundColor = Robust.Shared.Maths.Color.Transparent
            };

            return;
        }

        ButtonContainer.Margin = new(12.0f, 2.0f);

        Rounding rounding = Style switch
        {
            ButtonStyle.Default   => new(6.0f),
            ButtonStyle.OpenRight => new(6.0f, 0.0f, 0.0f, 6.0f),
            ButtonStyle.OpenBoth  => new(0.0f),
            ButtonStyle.OpenLeft  => new(0.0f, 6.0f, 6.0f, 0.0f),
            _                     => throw new ArgumentOutOfRangeException()
        };

        Color   backgroundColor;
        Border? insetBorders;

        if (Group is null)
        {
            backgroundColor = GetColorFor(Color, DrawMode);
            insetBorders    = null;
        }
        else
        {
            var insetBorderColor = GetColorFor(Color, DrawModeEnum.Normal);

            backgroundColor = Pressed ? insetBorderColor : Colors.WindowBackground;
            insetBorders = new(
                insetBorderColor,
                new(
                    rounding.TopLeft + rounding.BottomLeft == 0.0f ? 0.0f : 2.0f,
                    2.0f,
                    rounding.TopRight + rounding.BottomRight == 0.0f ? 0.0f : 2.0f,
                    2.0f
                )
            );
        }


        StyleBoxOverride = new RectBox
        {
            Rounding        = rounding,
            BackgroundColor = backgroundColor,
            InsetBorders    = insetBorders
        };
    }

    private static Color GetColorFor(ButtonColor buttonColor, DrawModeEnum drawMode) =>
        buttonColor switch
        {
            ButtonColor.Default => drawMode switch
            {
                DrawModeEnum.Disabled => Colors.ButtonDisabledBackground,
                DrawModeEnum.Pressed  => Colors.ButtonPressedBackground,
                _                     => Colors.ButtonBackground
            },
            ButtonColor.Accent => drawMode switch
            {
                DrawModeEnum.Disabled => Colors.ButtonAccentDisabledBackground,
                DrawModeEnum.Pressed  => Colors.ButtonAccentPressedBackground,
                _                     => Colors.ButtonAccentBackground
            },
            ButtonColor.Danger => drawMode switch
            {
                DrawModeEnum.Disabled => Colors.ButtonDangerDisabledBackground,
                DrawModeEnum.Pressed  => Colors.ButtonDangerPressedBackground,
                _                     => Colors.ButtonDangerBackground
            },
            _ => throw new ArgumentOutOfRangeException()
        };
}
